# -*- coding: utf-8 -*-
"""CSET340_E22CSEU0223(Lab-5)

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ajgPR_tgQ3W-5JstDTBa2mfh75Y7hteU
"""

from PIL import Image
import os
import matplotlib.pyplot as plt

def compress_image(input_path, output_path, quality=50, format='JPEG'):
    # Open the image
    image = Image.open('/content/Butterfly.png') #Changed to use the provided input path

    # Convert the image to RGB if saving as JPEG
    if format == 'JPEG':
        image = image.convert('RGB') #Convert the image to RGB before saving as a JPEG

    # Save the image with compression
    image.save(output_path, format=format, quality=quality if format == 'JPEG' else None, optimize=True)

    # Get file sizes
    original_size = os.path.getsize(input_path) / 1024  # KB
    compressed_size = os.path.getsize(output_path) / 1024  # KB

    print(f"Original Size: {original_size:.2f} KB")
    print(f"Compressed Size: {compressed_size:.2f} KB")
    print(f"Compression Ratio: {compressed_size/original_size:.2%}")

    return image, Image.open(output_path)


# Provide image paths (change these accordingly)
input_image = '/content/Butterfly.png'  # Replace with your image path. Now using Butterfly.png for consistency
jpeg_output = 'compressed_image.jpeg'
png_output = 'compressed_image.png'

# Perform lossy compression (JPEG) and assign returned values
original, jpeg_compressed = compress_image(input_image, jpeg_output, quality=50, format='JPEG')

# Perform lossless compression (PNG) and assign returned values
original, png_compressed = compress_image(input_image, png_output, format='PNG')

fig, axes = plt.subplots(1, 3, figsize=(15, 5))
axes[0].imshow(original)
axes[0].set_title("Original Image")
axes[0].axis("off")

axes[1].imshow(jpeg_compressed)
axes[1].set_title("JPEG Compressed Image")
axes[1].axis("off")

axes[2].imshow(png_compressed)
axes[2].set_title("PNG Compressed Image")
axes[2].axis("off")

plt.show()

import tensorflow as tf
from tensorflow import keras
from tensorflow.keras import layers
import matplotlib.pyplot as plt
from sklearn.metrics import classification_report, confusion_matrix, roc_curve, auc
import seaborn as sns
import numpy as np

# Load MNIST dataset
(x_train, y_train), (x_test, y_test) = keras.datasets.mnist.load_data()

# Normalize data
x_train, x_test = x_train / 255.0, x_test / 255.0

# Reshape for CNN
x_train = x_train.reshape(-1, 28, 28, 1)
x_test = x_test.reshape(-1, 28, 28, 1)

# Build CNN model
model = keras.Sequential([
    layers.Conv2D(32, (3,3), activation='relu', input_shape=(28,28,1)),
    layers.MaxPooling2D((2,2)),
    layers.Conv2D(64, (3,3), activation='relu'),
    layers.MaxPooling2D((2,2)),
    layers.Flatten(),
    layers.Dense(128, activation='relu'),
    layers.Dense(10, activation='softmax')
])

model.compile(optimizer='adam', loss='sparse_categorical_crossentropy', metrics=['accuracy'])

# Train model
history = model.fit(x_train, y_train, epochs=20, validation_data=(x_test, y_test), batch_size=64)

# Evaluate model
y_pred = model.predict(x_test)
y_pred_classes = np.argmax(y_pred, axis=1)

# Print classification report
print(classification_report(y_test, y_pred_classes))

# Confusion Matrix
conf_matrix = confusion_matrix(y_test, y_pred_classes)
sns.heatmap(conf_matrix, annot=True, fmt='d', cmap='Blues')
plt.title("Confusion Matrix")
plt.xlabel("Predicted")
plt.ylabel("True")
plt.show()

# ROC and AUC
y_test_binary = keras.utils.to_categorical(y_test, num_classes=10)
fpr, tpr, _ = roc_curve(y_test_binary.ravel(), y_pred.ravel())
roc_auc = auc(fpr, tpr)

plt.plot(fpr, tpr, label=f'AUC = {roc_auc:.3f}')
plt.xlabel("False Positive Rate")
plt.ylabel("True Positive Rate")
plt.title("ROC Curve")
plt.legend()
plt.show()

# Repeat same process for CIFAR-10
def load_cifar10():
    (x_train, y_train), (x_test, y_test) = keras.datasets.cifar10.load_data()
    x_train, x_test = x_train / 255.0, x_test / 255.0
    return (x_train, y_train), (x_test, y_test)

(x_train, y_train), (x_test, y_test) = load_cifar10()

# Reshape labels
y_train, y_test = y_train.flatten(), y_test.flatten()

# Build CNN for CIFAR-10
model_cifar = keras.Sequential([
    layers.Conv2D(32, (3,3), activation='relu', input_shape=(32,32,3)),
    layers.MaxPooling2D((2,2)),
    layers.Conv2D(64, (3,3), activation='relu'),
    layers.MaxPooling2D((2,2)),
    layers.Flatten(),
    layers.Dense(128, activation='relu'),
    layers.Dense(10, activation='softmax')
])

model_cifar.compile(optimizer='adam', loss='sparse_categorical_crossentropy', metrics=['accuracy'])

# Train CIFAR-10 model
history_cifar = model_cifar.fit(x_train, y_train, epochs=50, validation_data=(x_test, y_test), batch_size=64)

# Evaluate CIFAR-10 model
y_pred_cifar = model_cifar.predict(x_test)
y_pred_classes_cifar = np.argmax(y_pred_cifar, axis=1)

print(classification_report(y_test, y_pred_classes_cifar))

# Confusion Matrix for CIFAR-10
conf_matrix_cifar = confusion_matrix(y_test, y_pred_classes_cifar)
sns.heatmap(conf_matrix_cifar, annot=True, fmt='d', cmap='Blues')
plt.title("Confusion Matrix - CIFAR-10")
plt.xlabel("Predicted")
plt.ylabel("True")
plt.show()
