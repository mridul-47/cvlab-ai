# -*- coding: utf-8 -*-
"""Cset340-E22CSEU0223(Lab-3)

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/10r3rrQ71ouMLGQSs4YummLeRPtp1A0vw
"""

import cv2

# Read the image
image = cv2.imread("/content/sample.jpg")

import matplotlib.pyplot as plt

# Convert BGR to RGB and display
def display_image(image, title="Image"):
    image_rgb = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)  # Convert BGR to RGB
    plt.imshow(image_rgb)
    plt.title(title)
    plt.axis("off")
    plt.show()

display_image(image, "Original Image")

# Get image dimensions
height, width, channels = image.shape
print(f"Image Size: {height}x{width}, Channels: {channels}")

total_pixels = height * width
print(f"Total Pixels: {total_pixels}")

# Convert to grayscale
gray_image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

# Save and display grayscale image
cv2.imwrite("photo_gray.jpg", gray_image)
plt.imshow(gray_image, cmap="gray")
plt.title("Grayscale Image")
plt.axis("off")
plt.show()

# Convert to binary using thresholding
_, binary_image = cv2.threshold(gray_image, 127, 255, cv2.THRESH_BINARY)

# Save and display binary image
cv2.imwrite("photo_binary.jpg", binary_image)
plt.imshow(binary_image, cmap="gray")
plt.title("Binary Image")
plt.axis("off")
plt.show()

import numpy as np

# Count black pixels (value = 0)
black_pixels = np.sum(binary_image == 0)
print(f"Black Pixels Count: {black_pixels}")

# Sobel Edge Detection
sobel_x = cv2.Sobel(gray_image, cv2.CV_64F, 1, 0, ksize=5)
sobel_y = cv2.Sobel(gray_image, cv2.CV_64F, 0, 1, ksize=5)
sobel_edges = cv2.magnitude(sobel_x, sobel_y)

# Display
print(sobel_edges)
plt.imshow(sobel_edges, cmap="gray")
plt.title("Sobel Edge Detection")
plt.axis("off")
plt.show()

import numpy as np

# Define Prewitt kernels
kernel_x = np.array([[1, 1, 1], [0, 0, 0], [-1, -1, -1]])
kernel_y = np.array([[-1, 0, 1], [-1, 0, 1], [-1, 0, 1]])

# Apply Prewitt filter
prewitt_x = cv2.filter2D(gray_image, -1, kernel_x)
prewitt_y = cv2.filter2D(gray_image, -1, kernel_y)
prewitt_edges = prewitt_x + prewitt_y

print(prewitt_edges)

# Display
plt.imshow(prewitt_edges, cmap="gray")
plt.title("Prewitt Edge Detection")
plt.axis("off")
plt.show()

from skimage.filters import roberts

# Apply Roberts Cross filter
roberts_edges = roberts(gray_image)

# Display
plt.imshow(roberts_edges, cmap="gray")
plt.title("Roberts Edge Detection")
plt.axis("off")
plt.show()

# Apply Canny Edge Detection
canny_edges = cv2.Canny(gray_image, 100, 200)

# Display
plt.imshow(canny_edges, cmap="gray")
plt.title("Canny Edge Detection")
plt.axis("off")
plt.show()

from skimage.filters import threshold_otsu

# Apply Otsu's Thresholding
threshold_value = threshold_otsu(gray_image)
_, global_thresh = cv2.threshold(gray_image, threshold_value, 255, cv2.THRESH_BINARY)

# Display Global Thresholding
plt.imshow(global_thresh, cmap="gray")
plt.title("Global Thresholding")
plt.axis("off")
plt.show()

# Apply Adaptive Thresholding
adaptive_thresh = cv2.adaptiveThreshold(gray_image, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY, 11, 2)

# Display Adaptive Thresholding
plt.imshow(adaptive_thresh, cmap="gray")
plt.title("Adaptive Thresholding")
plt.axis("off")
plt.show()

# Display Canny Edge Detection Segmentation
plt.imshow(canny_edges, cmap="gray")
plt.title("Canny Edge Segmentation")
plt.axis("off")
plt.show()

# Convert to grayscale again (in case needed)
gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

# Apply binary thresholding
_, binary = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY_INV + cv2.THRESH_OTSU)

# Distance Transform
dist_transform = cv2.distanceTransform(binary, cv2.DIST_L2, 5)
_, sure_fg = cv2.threshold(dist_transform, 0.7 * dist_transform.max(), 255, 0)

# Finding unknown region
sure_fg = np.uint8(sure_fg)
unknown = cv2.subtract(binary, sure_fg)

# Marker labelling
_, markers = cv2.connectedComponents(sure_fg)
markers = markers + 1
markers[unknown == 255] = 0

# Apply Watershed
markers = cv2.watershed(image, markers)
image[markers == -1] = [255, 0, 0]

# Display Watershed Segmentation
plt.imshow(cv2.cvtColor(image, cv2.COLOR_BGR2RGB))
plt.title("Watershed Segmentation")
plt.axis("off")
plt.show()
